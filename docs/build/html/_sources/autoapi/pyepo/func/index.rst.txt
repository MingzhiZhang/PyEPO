:py:mod:`pyepo.func`
====================

.. py:module:: pyepo.func

.. autoapi-nested-parse::

   Pytorch autograd function for end-to-end training



Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   abcmodule/index.rst
   blackbox/index.rst
   contrastive/index.rst
   perturbed/index.rst
   rank/index.rst
   spoplus/index.rst
   utlis/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   pyepo.func.blackboxOpt
   pyepo.func.SPOPlus
   pyepo.func.perturbedOpt
   pyepo.func.perturbedFenchelYoung
   pyepo.func.NCE
   pyepo.func.contrastiveMAP
   pyepo.func.listwiseLTR
   pyepo.func.pairwiseLTR
   pyepo.func.pointwiseLTR




.. py:class:: blackboxOpt(optmodel, lambd=10, processes=1, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for differentiable black-box optimizer, which yield
   optimal a solution and derive a gradient.

   For differentiable block-box, the objective function is linear and
   constraints are known and fixed, but the cost vector need to be predicted
   from contextual data.

   The block-box approximate gradient of optimizer smoothly. Thus, allows us to
   design an algorithm based on stochastic gradient descent.

   Reference: <https://arxiv.org/abs/1912.02175>

   .. py:method:: forward(pred_cost)

      Forward pass



.. py:class:: SPOPlus(optmodel, processes=1, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for SPO+ Loss, as a surrogate loss function of SPO Loss,
   which measures the decision error of optimization problem.

   For SPO/SPO+ Loss, the objective function is linear and constraints are
   known and fixed, but the cost vector need to be predicted from contextual
   data.

   The SPO+ Loss is convex with subgradient. Thus, allows us to design an
   algorithm based on stochastic gradient descent.

   Reference: <https://doi.org/10.1287/mnsc.2020.3922>

   .. py:method:: forward(pred_cost, true_cost, true_sol, true_obj, reduction='mean')

      Forward pass



.. py:class:: perturbedOpt(optmodel, n_samples=10, sigma=1.0, processes=1, seed=135, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for differentiable perturbed optimizer, in which random
   perturbed costs are sampled to optimize.

   For the perturbed optimizer, the cost vector need to be predicted from
   contextual data and are perturbed with Gaussian noise.

   The perturbed optimizer differentiable in its inputs with non-zero Jacobian.
   Thus, allows us to design an algorithm based on stochastic gradient descent.

   Reference: <https://papers.nips.cc/paper/2020/hash/6bb56208f672af0dd65451f869fedfd9-Abstract.html>

   .. py:method:: forward(pred_cost)

      Forward pass



.. py:class:: perturbedFenchelYoung(optmodel, n_samples=10, sigma=1.0, processes=1, seed=135, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for Fenchel-Young loss using perturbation techniques. The
   use of the loss improves the algorithmic by the specific expression of the
   gradients of the loss.

   For the perturbed optimizer, the cost vector need to be predicted from
   contextual data and are perturbed with Gaussian noise.

   The Fenchel-Young loss allows to directly optimize a loss between the features
   and solutions with less computation. Thus, allows us to design an algorithm
   based on stochastic gradient descent.

   Reference: <https://papers.nips.cc/paper/2020/hash/6bb56208f672af0dd65451f869fedfd9-Abstract.html>

   .. py:method:: forward(pred_cost, true_sol, reduction='mean')

      Forward pass



.. py:class:: NCE(optmodel, processes=1, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for noise contrastive estimation as surrogate loss
   functions, based on viewing non-optimal solutions as negative examples.

   For the NCE, the cost vector needs to be predicted from contextual data and
   maximizes the separation of the probability of the optimal solution.

   Thus, allows us to design an algorithm based on stochastic gradient descent.

   Reference: <https://www.ijcai.org/proceedings/2021/390>

   .. py:method:: forward(pred_cost, true_sol, reduction='mean')

      Forward pass



.. py:class:: contrastiveMAP(optmodel, processes=1, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for Maximum A Posterior contrastive estimation as
   surrogate loss functions, which is a efficient self-contrastive algorithm.

   For the MAP, the cost vector needs to be predicted from contextual data and
   maximizes the separation of the probability of the optimal solution.

   Thus, allows us to design an algorithm based on stochastic gradient descent.

   Reference: <https://www.ijcai.org/proceedings/2021/390>

   .. py:method:: forward(pred_cost, true_sol, reduction='mean')

      Forward pass



.. py:class:: listwiseLTR(optmodel, processes=1, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for listwise learning to rank, where the goal is to learn
   an objective function that ranks a pool of feasible solutions correctly.

   For the listwise LTR, the cost vector needs to be predicted from contextual
   data, and the loss measures the scores of the whole ranked lists.

   Thus, allows us to design an algorithm based on stochastic gradient descent.

   Reference: <https://proceedings.mlr.press/v162/mandi22a.html>

   .. py:method:: forward(pred_cost, true_cost, reduction='mean')

      Forward pass



.. py:class:: pairwiseLTR(optmodel, processes=1, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for pairwise learning to rank, where the goal is to learn
   an objective function that ranks a pool of feasible solutions correctly.

   For the pairwise LTR, the cost vector needs to be predicted from contextual
   data, and the loss learns the relative ordering of pairs of items.

   Thus, allows us to design an algorithm based on stochastic gradient descent.

   Reference: <https://proceedings.mlr.press/v162/mandi22a.html>

   .. py:method:: forward(pred_cost, true_cost, reduction='mean')

      Forward pass



.. py:class:: pointwiseLTR(optmodel, processes=1, solve_ratio=1, dataset=None)

   Bases: :py:obj:`pyepo.func.abcmodule.optModule`

   An autograd module for pointwise learning to rank, where the goal is to
   learn an objective function that ranks a pool of feasible solutions
   correctly.

   For the pointwise LTR, the cost vector needs to be predicted from contextual
   data, and calculates the ranking scores of the items.

   Thus, allows us to design an algorithm based on stochastic gradient descent.

   Reference: <https://proceedings.mlr.press/v162/mandi22a.html>

   .. py:method:: forward(pred_cost, true_cost, reduction='mean')

      Forward pass



